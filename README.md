# Transverse KMUTT
*The most efficient path to transverse between building in KMUTT*

In this project, we would like to explore and solve the most efficient path to transverse between building in KMUTT problem. In many times, standing in the intersection and ask yourself, “What is the shortest path to get to building A” “How can I get to building B quickest”. This problem is difficult to solve because of the human perceptions, which are different from people to people. However, we can lose our time and important opportunity by traversing with inefficient path. Moreover, using online tools such as Google Maps can gives you wrong answer because it can only process for roadways, not footpath or shortcuts between buildings. So, we want to apply our knowledge in discrete mathematics to it.

We have learned that graph theory can be used for solving this kind of problem, so we look for pathfinding algorithm. We found that A* search algorithm (read as A star) can be used in this problem. A* search algorithm is the algorithm which use heuristics in calculating for the shortest path. Because A* search algorithm didn’t do a calculation for every node in graph, it is very popular algorithm to use because of its good performance. When A* algorithm is applied, it performs a calculation ![f(x) = g(x) + h(x)](https://latex.codecogs.com/png.latex?\bg_white&space;f(x)&space;=&space;g(x)&space;&plus;&space;h(x)) to starting node’s neighbor node which ![g(x)](https://latex.codecogs.com/png.latex?\bg_white&space;g(x)) is the cost (how much it takes from starting node to it), and ![h(x)](https://latex.codecogs.com/png.latex?\bg_white&space;h(x)) is the heuristic (how long from it to target node). By traversing to the next lowest ![f(x)](https://latex.codecogs.com/png.latex?\bg_white&space;f(x)) node and perform a calculation to the node’s neighbors one by one, you will be ended up with the shortest path from the starting node to the target node.

With this method, you can apply the algorithm over 2D image where each pixel is a node and tell it if some pixel is a node that cannot get to (like a solid building), then applied the algorithm over it. In the end, we will get a path from our starting point to the end. And yet, solve our problem.
