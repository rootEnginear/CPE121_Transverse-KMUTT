# Transverse KMUTT
*The most efficient path to transverse between buildings in KMUTT*

In this project, we would like to explore and solve ‘the most efficient path to transverse between buildings in KMUTT’ problem. In many times, standing at an intersection and asking yourself, “What is the shortest path to get to building A” or “How can I get to building B quickest”. This problem is difficult to solve for humans because of our perceptions which are different from people to people. In fact, we can lose our time and important opportunity by using inefficient path. Moreover, using online tools such as Google Maps can give you inaccurate answer as it can only process roadways, not footpath or shortcuts between buildings. So, we want to apply our discrete mathematics knowledge to it.

We have learned that graph theory can be used for solving this kind of problem, so we look for pathfinding algorithm. We found that A* search algorithm (read as A star) is suitable to be used in this problem. A* search algorithm is the algorithm which use heuristic function in calculation for the shortest path. Because A* search algorithm did not apply calculation for every node in graph, it is very popular algorithm to use because of its good performance. When A* algorithm is applied, it performs calculation ![f(x) = g(x) + h(x)](https://latex.codecogs.com/png.latex?\bg_white&space;f(x)&space;=&space;g(x)&space;&plus;&space;h(x)) to starting node’s neighbor nodes which ![g(x)](https://latex.codecogs.com/png.latex?\bg_white&space;g(x)) is the cost (how much it takes from starting node to it), and ![h(x)](https://latex.codecogs.com/png.latex?\bg_white&space;h(x)) is the heuristic value (how long from it to target node). By traversing to the next lowest ![f(x)](https://latex.codecogs.com/png.latex?\bg_white&space;f(x)) node and perform calculation to the node’s neighbors one by one, you will be ended up with the shortest path from the starting node to the target node.

With this method, we apply the algorithm over an image by treating each pixel as a node and tell the algorithm if some pixel is a node that cannot get to (like a solid building). Then, applied the algorithm over it. In the end, we will get a path from our starting point to the end. And yet, solve our problem.
